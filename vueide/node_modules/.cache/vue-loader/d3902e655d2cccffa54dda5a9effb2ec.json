{"remainingRequest":"C:\\Users\\DRACO\\PycharmProjects\\Data-Science-Term-Project-1\\vueide\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\DRACO\\PycharmProjects\\Data-Science-Term-Project-1\\vueide\\node_modules\\vue-codemirror\\src\\codemirror.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\DRACO\\PycharmProjects\\Data-Science-Term-Project-1\\vueide\\node_modules\\vue-codemirror\\src\\codemirror.vue","mtime":499162500000},{"path":"C:\\Users\\DRACO\\PycharmProjects\\Data-Science-Term-Project-1\\vueide\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\DRACO\\PycharmProjects\\Data-Science-Term-Project-1\\vueide\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\DRACO\\PycharmProjects\\Data-Science-Term-Project-1\\vueide\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\DRACO\\PycharmProjects\\Data-Science-Term-Project-1\\vueide\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KCi8vIGxpYgppbXBvcnQgX0NvZGVNaXJyb3IgZnJvbSAnY29kZW1pcnJvcicKY29uc3QgQ29kZU1pcnJvciA9IHdpbmRvdy5Db2RlTWlycm9yIHx8IF9Db2RlTWlycm9yCgovLyBwb2xsZmlsbAppZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT0gJ2Z1bmN0aW9uJykgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7CiAgICB2YWx1ZSh0YXJnZXQsIHZhckFyZ3MpIHsKICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7CiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0JykKICAgICAgfQogICAgICBjb25zdCB0byA9IE9iamVjdCh0YXJnZXQpCiAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0KICAgICAgICBpZiAobmV4dFNvdXJjZSAhPSBudWxsKSB7CiAgICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgaW4gbmV4dFNvdXJjZSkgewogICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7CiAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIHRvCiAgICB9LAogICAgd3JpdGFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUKICB9KQp9CgovLyBleHBvcnQKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICdjb2RlbWlycm9yJywKICBkYXRhKCkgewogICAgcmV0dXJuIHsKICAgICAgY29udGVudDogJycsCiAgICAgIGNvZGVtaXJyb3I6IG51bGwsCiAgICAgIGNtaW5zdGFuY2U6IG51bGwKICAgIH0KICB9LAogIHByb3BzOiB7CiAgICBjb2RlOiBTdHJpbmcsCiAgICB2YWx1ZTogU3RyaW5nLAogICAgbWFya2VyOiBGdW5jdGlvbiwKICAgIHVuc2VlbkxpbmVzOiBBcnJheSwKICAgIG5hbWU6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICBkZWZhdWx0OiAnY29kZW1pcnJvcicKICAgIH0sCiAgICBwbGFjZWhvbGRlcjogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICcnCiAgICB9LAogICAgbWVyZ2U6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICBvcHRpb25zOiB7CiAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgZGVmYXVsdDogKCkgPT4gKHt9KQogICAgfSwKICAgIGV2ZW50czogewogICAgICB0eXBlOiBBcnJheSwKICAgICAgZGVmYXVsdDogKCkgPT4gKFtdKQogICAgfSwKICAgIGdsb2JhbE9wdGlvbnM6IHsKICAgICAgdHlwZTogT2JqZWN0LAogICAgICBkZWZhdWx0OiAoKSA9PiAoe30pCiAgICB9LAogICAgZ2xvYmFsRXZlbnRzOiB7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICBkZWZhdWx0OiAoKSA9PiAoW10pCiAgICB9CiAgfSwKICB3YXRjaDogewogICAgb3B0aW9uczogewogICAgICBkZWVwOiB0cnVlLAogICAgICBoYW5kbGVyKG9wdGlvbnMpIHsKICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7CiAgICAgICAgICB0aGlzLmNtaW5zdGFuY2Uuc2V0T3B0aW9uKGtleSwgb3B0aW9uc1trZXldKQogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIG1lcmdlKCkgewogICAgICB0aGlzLiRuZXh0VGljayh0aGlzLnN3aXRjaE1lcmdlKQogICAgfSwKICAgIGNvZGUobmV3VmFsKSB7CiAgICAgIHRoaXMuaGFuZGVyQ29kZUNoYW5nZShuZXdWYWwpCiAgICB9LAogICAgdmFsdWUobmV3VmFsKSB7CiAgICAgIHRoaXMuaGFuZGVyQ29kZUNoYW5nZShuZXdWYWwpCiAgICB9LAogIH0sCiAgbWV0aG9kczogewogICAgaW5pdGlhbGl6ZSgpIHsKICAgICAgY29uc3QgY21PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nbG9iYWxPcHRpb25zLCB0aGlzLm9wdGlvbnMpCiAgICAgIGlmICh0aGlzLm1lcmdlKSB7CiAgICAgICAgdGhpcy5jb2RlbWlycm9yID0gQ29kZU1pcnJvci5NZXJnZVZpZXcodGhpcy4kcmVmcy5tZXJnZXZpZXcsIGNtT3B0aW9ucykKICAgICAgICB0aGlzLmNtaW5zdGFuY2UgPSB0aGlzLmNvZGVtaXJyb3IuZWRpdAogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuY29kZW1pcnJvciA9IENvZGVNaXJyb3IuZnJvbVRleHRBcmVhKHRoaXMuJHJlZnMudGV4dGFyZWEsIGNtT3B0aW9ucykKICAgICAgICB0aGlzLmNtaW5zdGFuY2UgPSB0aGlzLmNvZGVtaXJyb3IKICAgICAgICB0aGlzLmNtaW5zdGFuY2Uuc2V0VmFsdWUodGhpcy5jb2RlIHx8IHRoaXMudmFsdWUgfHwgdGhpcy5jb250ZW50KQogICAgICB9CiAgICAgIHRoaXMuY21pbnN0YW5jZS5vbignY2hhbmdlJywgY20gPT4gewogICAgICAgIHRoaXMuY29udGVudCA9IGNtLmdldFZhbHVlKCkKICAgICAgICBpZiAodGhpcy4kZW1pdCkgewogICAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmNvbnRlbnQpCiAgICAgICAgfQogICAgICB9KQoKICAgICAgLy8g5omA5pyJ5pyJ5pWI5LqL5Lu277yI6am85bOw5ZG95ZCN77yJKyDljrvph40KICAgICAgY29uc3QgdG1wRXZlbnRzID0ge30KICAgICAgY29uc3QgYWxsRXZlbnRzID0gWwogICAgICAgICdzY3JvbGwnLAogICAgICAgICdjaGFuZ2VzJywKICAgICAgICAnYmVmb3JlQ2hhbmdlJywKICAgICAgICAnY3Vyc29yQWN0aXZpdHknLAogICAgICAgICdrZXlIYW5kbGVkJywKICAgICAgICAnaW5wdXRSZWFkJywKICAgICAgICAnZWxlY3RyaWNJbnB1dCcsCiAgICAgICAgJ2JlZm9yZVNlbGVjdGlvbkNoYW5nZScsCiAgICAgICAgJ3ZpZXdwb3J0Q2hhbmdlJywKICAgICAgICAnc3dhcERvYycsCiAgICAgICAgJ2d1dHRlckNsaWNrJywKICAgICAgICAnZ3V0dGVyQ29udGV4dE1lbnUnLAogICAgICAgICdmb2N1cycsCiAgICAgICAgJ2JsdXInLAogICAgICAgICdyZWZyZXNoJywKICAgICAgICAnb3B0aW9uQ2hhbmdlJywKICAgICAgICAnc2Nyb2xsQ3Vyc29ySW50b1ZpZXcnLAogICAgICAgICd1cGRhdGUnCiAgICAgIF0KICAgICAgLmNvbmNhdCh0aGlzLmV2ZW50cykKICAgICAgLmNvbmNhdCh0aGlzLmdsb2JhbEV2ZW50cykKICAgICAgLmZpbHRlcihlID0+ICghdG1wRXZlbnRzW2VdICYmICh0bXBFdmVudHNbZV0gPSB0cnVlKSkpCiAgICAgIC5mb3JFYWNoKGV2ZW50ID0+IHsKICAgICAgICAvLyDlvqrnjq/kuovku7bvvIzlubblhbzlrrkgcnVuLXRpbWUg5LqL5Lu25ZG95ZCNCiAgICAgICAgdGhpcy5jbWluc3RhbmNlLm9uKGV2ZW50LCAoLi4uYXJncykgPT4gewogICAgICAgICAgLy8gY29uc29sZS5sb2coJ+W9k+acieS6i+S7tuinpuWPkeS6hicsIGV2ZW50LCBhcmdzKQogICAgICAgICAgdGhpcy4kZW1pdChldmVudCwgLi4uYXJncykKICAgICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykudG9Mb3dlckNhc2UoKQogICAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCkgewogICAgICAgICAgICB0aGlzLiRlbWl0KGxvd2VyQ2FzZUV2ZW50LCAuLi5hcmdzKQogICAgICAgICAgfQogICAgICAgIH0pCiAgICAgIH0pCgogICAgICB0aGlzLiRlbWl0KCdyZWFkeScsIHRoaXMuY29kZW1pcnJvcikKICAgICAgdGhpcy51bnNlZW5MaW5lTWFya2VycygpCgogICAgICAvLyBwcmV2ZW50cyBmdW5reSBkeW5hbWljIHJlbmRlcmluZwogICAgICB0aGlzLnJlZnJlc2goKQogICAgfSwKICAgIHJlZnJlc2goKSB7CiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHsKICAgICAgICB0aGlzLmNtaW5zdGFuY2UucmVmcmVzaCgpCiAgICAgIH0pCiAgICB9LAogICAgZGVzdHJveSgpIHsKICAgICAgLy8gZ2FyYmFnZSBjbGVhbnVwCiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNtaW5zdGFuY2UuZG9jLmNtLmdldFdyYXBwZXJFbGVtZW50KCkKICAgICAgZWxlbWVudCAmJiBlbGVtZW50LnJlbW92ZSAmJiBlbGVtZW50LnJlbW92ZSgpCiAgICB9LAogICAgaGFuZGVyQ29kZUNoYW5nZShuZXdWYWwpIHsKICAgICAgY29uc3QgY21fdmFsdWUgPSB0aGlzLmNtaW5zdGFuY2UuZ2V0VmFsdWUoKQogICAgICBpZiAobmV3VmFsICE9PSBjbV92YWx1ZSkgewogICAgICAgIGNvbnN0IHNjcm9sbEluZm8gPSB0aGlzLmNtaW5zdGFuY2UuZ2V0U2Nyb2xsSW5mbygpCiAgICAgICAgdGhpcy5jbWluc3RhbmNlLnNldFZhbHVlKG5ld1ZhbCkKICAgICAgICB0aGlzLmNvbnRlbnQgPSBuZXdWYWwKICAgICAgICB0aGlzLmNtaW5zdGFuY2Uuc2Nyb2xsVG8oc2Nyb2xsSW5mby5sZWZ0LCBzY3JvbGxJbmZvLnRvcCkKICAgICAgfQogICAgICB0aGlzLnVuc2VlbkxpbmVNYXJrZXJzKCkKICAgIH0sCiAgICB1bnNlZW5MaW5lTWFya2VycygpIHsKICAgICAgaWYgKHRoaXMudW5zZWVuTGluZXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm1hcmtlciAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgdGhpcy51bnNlZW5MaW5lcy5mb3JFYWNoKGxpbmUgPT4gewogICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuY21pbnN0YW5jZS5saW5lSW5mbyhsaW5lKQogICAgICAgICAgdGhpcy5jbWluc3RhbmNlLnNldEd1dHRlck1hcmtlcihsaW5lLCAnYnJlYWtwb2ludHMnLCBpbmZvLmd1dHRlck1hcmtlcnMgPyBudWxsIDogdGhpcy5tYXJrZXIoKSkKICAgICAgICB9KQogICAgICB9CiAgICB9LAogICAgc3dpdGNoTWVyZ2UoKSB7CiAgICAgIC8vIFNhdmUgY3VycmVudCB2YWx1ZXMKICAgICAgY29uc3QgaGlzdG9yeSA9IHRoaXMuY21pbnN0YW5jZS5kb2MuaGlzdG9yeQogICAgICBjb25zdCBjbGVhbkdlbmVyYXRpb24gPSB0aGlzLmNtaW5zdGFuY2UuZG9jLmNsZWFuR2VuZXJhdGlvbgogICAgICB0aGlzLm9wdGlvbnMudmFsdWUgPSB0aGlzLmNtaW5zdGFuY2UuZ2V0VmFsdWUoKQoKICAgICAgdGhpcy5kZXN0cm95KCkKICAgICAgdGhpcy5pbml0aWFsaXplKCkKCiAgICAgIC8vIFJlc3RvcmUgdmFsdWVzCiAgICAgIHRoaXMuY21pbnN0YW5jZS5kb2MuaGlzdG9yeSA9IGhpc3RvcnkKICAgICAgdGhpcy5jbWluc3RhbmNlLmRvYy5jbGVhbkdlbmVyYXRpb24gPSBjbGVhbkdlbmVyYXRpb24KICAgIH0KICB9LAogIG1vdW50ZWQoKSB7CiAgICB0aGlzLmluaXRpYWxpemUoKQogIH0sCiAgYmVmb3JlRGVzdHJveSgpIHsKICAgIHRoaXMuZGVzdHJveSgpCiAgfQp9Cg=="},{"version":3,"sources":["codemirror.vue"],"names":[],"mappings":";;;;;;;;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"codemirror.vue","sourceRoot":"node_modules/vue-codemirror/src","sourcesContent":["<template>\n  <div class=\"vue-codemirror\" :class=\"{ merge }\">\n    <div ref=\"mergeview\" v-if=\"merge\"></div>\n    <textarea ref=\"textarea\" :name=\"name\" :placeholder=\"placeholder\" v-else></textarea>\n  </div>\n</template>\n\n<script>\n  // lib\n  import _CodeMirror from 'codemirror'\n  const CodeMirror = window.CodeMirror || _CodeMirror\n\n  // pollfill\n  if (typeof Object.assign != 'function') {\n    Object.defineProperty(Object, 'assign', {\n      value(target, varArgs) {\n        if (target == null) {\n          throw new TypeError('Cannot convert undefined or null to object')\n        }\n        const to = Object(target)\n        for (let index = 1; index < arguments.length; index++) {\n          const nextSource = arguments[index]\n          if (nextSource != null) {\n            for (const nextKey in nextSource) {\n              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                to[nextKey] = nextSource[nextKey]\n              }\n            }\n          }\n        }\n        return to\n      },\n      writable: true,\n      configurable: true\n    })\n  }\n\n  // export\n  export default {\n    name: 'codemirror',\n    data() {\n      return {\n        content: '',\n        codemirror: null,\n        cminstance: null\n      }\n    },\n    props: {\n      code: String,\n      value: String,\n      marker: Function,\n      unseenLines: Array,\n      name: {\n        type: String,\n        default: 'codemirror'\n      },\n      placeholder: {\n        type: String,\n        default: ''\n      },\n      merge: {\n        type: Boolean,\n        default: false\n      },\n      options: {\n        type: Object,\n        default: () => ({})\n      },\n      events: {\n        type: Array,\n        default: () => ([])\n      },\n      globalOptions: {\n        type: Object,\n        default: () => ({})\n      },\n      globalEvents: {\n        type: Array,\n        default: () => ([])\n      }\n    },\n    watch: {\n      options: {\n        deep: true,\n        handler(options) {\n          for (const key in options) {\n            this.cminstance.setOption(key, options[key])\n          }\n        }\n      },\n      merge() {\n        this.$nextTick(this.switchMerge)\n      },\n      code(newVal) {\n        this.handerCodeChange(newVal)\n      },\n      value(newVal) {\n        this.handerCodeChange(newVal)\n      },\n    },\n    methods: {\n      initialize() {\n        const cmOptions = Object.assign({}, this.globalOptions, this.options)\n        if (this.merge) {\n          this.codemirror = CodeMirror.MergeView(this.$refs.mergeview, cmOptions)\n          this.cminstance = this.codemirror.edit\n        } else {\n          this.codemirror = CodeMirror.fromTextArea(this.$refs.textarea, cmOptions)\n          this.cminstance = this.codemirror\n          this.cminstance.setValue(this.code || this.value || this.content)\n        }\n        this.cminstance.on('change', cm => {\n          this.content = cm.getValue()\n          if (this.$emit) {\n            this.$emit('input', this.content)\n          }\n        })\n\n        // 所有有效事件（驼峰命名）+ 去重\n        const tmpEvents = {}\n        const allEvents = [\n          'scroll',\n          'changes',\n          'beforeChange',\n          'cursorActivity',\n          'keyHandled',\n          'inputRead',\n          'electricInput',\n          'beforeSelectionChange',\n          'viewportChange',\n          'swapDoc',\n          'gutterClick',\n          'gutterContextMenu',\n          'focus',\n          'blur',\n          'refresh',\n          'optionChange',\n          'scrollCursorIntoView',\n          'update'\n        ]\n        .concat(this.events)\n        .concat(this.globalEvents)\n        .filter(e => (!tmpEvents[e] && (tmpEvents[e] = true)))\n        .forEach(event => {\n          // 循环事件，并兼容 run-time 事件命名\n          this.cminstance.on(event, (...args) => {\n            // console.log('当有事件触发了', event, args)\n            this.$emit(event, ...args)\n            const lowerCaseEvent = event.replace(/([A-Z])/g, '-$1').toLowerCase()\n            if (lowerCaseEvent !== event) {\n              this.$emit(lowerCaseEvent, ...args)\n            }\n          })\n        })\n\n        this.$emit('ready', this.codemirror)\n        this.unseenLineMarkers()\n\n        // prevents funky dynamic rendering\n        this.refresh()\n      },\n      refresh() {\n        this.$nextTick(() => {\n          this.cminstance.refresh()\n        })\n      },\n      destroy() {\n        // garbage cleanup\n        const element = this.cminstance.doc.cm.getWrapperElement()\n        element && element.remove && element.remove()\n      },\n      handerCodeChange(newVal) {\n        const cm_value = this.cminstance.getValue()\n        if (newVal !== cm_value) {\n          const scrollInfo = this.cminstance.getScrollInfo()\n          this.cminstance.setValue(newVal)\n          this.content = newVal\n          this.cminstance.scrollTo(scrollInfo.left, scrollInfo.top)\n        }\n        this.unseenLineMarkers()\n      },\n      unseenLineMarkers() {\n        if (this.unseenLines !== undefined && this.marker !== undefined) {\n          this.unseenLines.forEach(line => {\n            const info = this.cminstance.lineInfo(line)\n            this.cminstance.setGutterMarker(line, 'breakpoints', info.gutterMarkers ? null : this.marker())\n          })\n        }\n      },\n      switchMerge() {\n        // Save current values\n        const history = this.cminstance.doc.history\n        const cleanGeneration = this.cminstance.doc.cleanGeneration\n        this.options.value = this.cminstance.getValue()\n\n        this.destroy()\n        this.initialize()\n\n        // Restore values\n        this.cminstance.doc.history = history\n        this.cminstance.doc.cleanGeneration = cleanGeneration\n      }\n    },\n    mounted() {\n      this.initialize()\n    },\n    beforeDestroy() {\n      this.destroy()\n    }\n  }\n</script>\n"]}]}