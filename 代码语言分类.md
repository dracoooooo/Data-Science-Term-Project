## 代码语言分类

### 概述

使用神经网络实现了对`java`,`python`,`javascript`,`c/c++`四种语言的文本代码分类。

### 特征提取

我们在[开源数据集](http://learnbigcode.github.io/datasets/)和[github](https://github.com/)上收集上述四种语言的代码文件。先通过文件的后缀名判定代码文件的语言，然后每种语言各取1000份作为测试集，500份作为验证集。使用训练集中的代码文本训练分词器，得到如下的字典：

```java
{';': 1, 'the': 2, 'if': 3, '0': 4, '#': 5, "'": 6, 'return': 7, '1': 8, 'this': 9, 'a': 10, 'to': 11, 'self': 12, 'i': 13, 'int': 14, 'is': 15, 'of': 16, 'for': 17, 'function': 18, 'in': 19, 't': 20, 'null': 21, 'sqlite': 22, 'var': 23, 'p': 24, '2': 25, 'name': 26, 'n': 27, 'config': 28, 'and': 29, 'void': 30, 'else': 31, 'import': 32, 'value': 33, 'sqlite3': 34, 'mode': 35, 'char': 36, 'c': 37, 'const': 38, 's': 39, 'string': 40, 'decimal': 41, 'bignumber': 42, 'places': 43, 'not': 44, 'or': 45, 'data': 46, 'static': 47, 'type': 48, 'true': 49, 'new': 50, 'file': 51, 'rounding': 52, 'from': 53, 'r': 54, 'x': 55, 'gl': 56, 'def': 57, 'rc': 58, 'endif': 59, 'error': 60, 'that': 61, 'be': 62, 'id': 63, 'false': 64, 'public': 65, 'case': 66, 'assert': 67, '3': 68, 'get': 69, 'test': 70, 'an': 71, 'size': 72, '4': 73, 'struct': 74, 'db': 75, 'length': 76, 'column': 77, 'it': 78, 'line': 79, 'd': 80, 'list': 81, 'with': 82, 'g': 83, 'on': 84, 'by': 85, 'none': 86, 'options': 87, 'as': 88, 'break': 89, 'v': 90, 'key': 91, 'define': 92, 'e': 93, 'start': 94, 'object': 95, 'set': 96, 'end': 97, 'table': 98, 'class': 99, 'path': 100...
```

上面的字典中元素排列的顺序是单词(字符)在1000 * 4份代码文件中出现的频率。使用训练好的分词器将训练集中的代码文本序列化，即在字典中找到单词对应的数字，用数字来填充字符串序列。比如：

```java
class test{
    public static void main(){
		System.out.println("Hello World");
    }
}
```

上述代码文本序列化后的结果为：

```python
[99, 70, 65, 47, 30, 332, 324, 129, 816, 1]
```

由于分词器训练时过滤了一些符号，比如`()`、`.`、`{}`，所以序列化的结果中并不会出现这些符号。同时分词器在训练时也保留了一些可以作为代码语言特征的符号，比如`；`，经测试可以提高一些模型的准确率。

关于特征的提取，我们选取`tokenizer.word_index`（即上述字典）的前1000个词，以代码文本中是否出现这个词作为特征，即出现了这个词为1，未出现这个词为0，构成了一个1000维的特征向量。上面的示例代码构成的特征向量是`f = [0, 1, ....]`，即`f[1], f[30], f[47]... = 1`，其他维度上均为0。

### 训练模型

我们使用上述特征训练模型。将每个训练样本转换成特征向量，并使用`one-hot`编码给数据添加`label`。

```python
label = {
    "java": 	[1, 0, 0, 0],
    "python": 	[0, 1, 0, 0],
    "js": 		[0, 0, 1, 0],
    "ccpp": 	[0, 0, 0, 1]
}
```

初始化一个神经网络模型：

```
Model: "sequential"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
dense (Dense)                (None, 1000)              1001000   
_________________________________________________________________
dense_1 (Dense)              (None, 200)               200200    
_________________________________________________________________
dense_2 (Dense)              (None, 4)                 804       
=================================================================
Total params: 1,202,004
Trainable params: 1,202,004
Non-trainable params: 0
_________________________________________________________________
```

```python
model = Sequential()
model.add(Dense(input_dim=features, units=1000, activation='relu'))
model.add(Dense(units=200, activation='relu'))
model.add(Dense(units=4, activation='softmax'))
# configuration
model.compile(loss='categorical_crossentropy',
              optimizer='adagrad',
              metrics=['accuracy'])
```

训练60个`epoch`后得到如下图像：

![lang_adagrad](https://draco-picbed.oss-cn-shanghai.aliyuncs.com/img/lang_adagrad.png)

![lang_adagrad_loss](https://draco-picbed.oss-cn-shanghai.aliyuncs.com/img/lang_adagrad_loss.png)

最后得到的模型在验证集上的准确率大致为`97%`。

## 代码功能分类

### 特征提取

基于上面代码语言分类的思路，我们在代码功能分类的特征提取方面一共尝试了3种方法：

1. 提取和代码语言分类相同的特征
2. 词袋模型 + 关键词权重
3. ast先序遍历

#### 

